# about temrs
- 퀴즈(12.16) -> 중간(12.31) -> 퀴즈(1.7) -> 기말(1.13)
- cheating paper 가져올 수 있음

chapter 01

# 연립일차방정식
- 해(solution)
- 해집합 : 해의 집합을 구하는 것. 이거 구하라고 하면 무조건 집합 표기를 해야 함
    비동차연립방정식 : 모두 해가 유일할 수도 있고, 없을 수도 있고, 무수히 많을 수도 있음
    동차연립방정식 : 유일한 해(x = 0) 혹은 무수히 많은 해
- 동차방정식 : 상수항이 0인 방정식
- 계수(coefficient) : 걸쳐 있다. 미지수에 스케일되어 있는 수

ex) 01
- 해집합 구하시오
-> sol) 1. 7x - 5y = -1
         매개변수 s를 선언. 
         y = s, x = (5//7)s - 1/7
         ∴ 해집합 = {(x, y) | x = (5//7)s - 1/7, y = s, s ∈ ℝ}

        2. 6x - 8y + 10z = 3
         매개변수 s, t 선언
         y = s, z = t, x = 1/2 + 3/4s - 3/5t
         ∴ 해집합 = {(x, y, z) | y = s, z = t, x = 1/2 + 3/4s - 3/5t, s, t ∈ ℝ}

- 연립일차방정식의 해의 개수:
    식의 개수 < 미지수 개수
    식의 개수 = 미지수 개수
    식의 개수 > 미지수 개수 : 모두 해가 유일할 수도 있고, 없을 수도 있고, 무수히 많을 수도 있음
- 동치(equivalent) : 동일한 해집합을 가지는 두 연립일차방정식

# 첨가행렬
- 첨가행렬(augmented matrix) : 좌항의 계수만 모아놓고 우항의 값을 첨가하여 만든 행렬
- 기본 식 연산 : 연립일차방정식을 동치인 연립일차방정식으로 바꾸는 방법
    두 식 교환
    한 식에 0이 아닌 상수를 곱합
    0이 아닌 상수를 곱하여 다른 행에 더함
- 기본행연산(elementary row operation) : 
    Eᵢⱼ : 두 행 교환                                    det = -1
    Eᵢ(c) : 한 행에 0이 아닌 상수를 곱합                    det = c
    Eᵢⱼ(c) : 0이 아닌 상수를 곱하여 다른 행에 더함            det = 1
    notation : A₁ E₁₂~ A₂ -> A₁에서 1행과 2행을 바꾼 것이 A₂이다, ~ 위에 E 씀
               A₁ E₁₂(-3)~ A₂ 
               [] ~ [] ~ ... ~ []
    prop : 기본 행 연산을 통해 만들어진 행렬은 모두 행동치(row equivalent)임. 예시로 위의 A₁와 A₂는 행동치임

    Eᵢⱼ의 역함수 : Eⱼᵢ
    Eᵢ(c)의 역함수 : Eᵢ(1/c)
    Eᵢⱼ(c)의 역함수 : Eᵢⱼ(-c)

TODO
ex) 1.1 - 18

ex) 1.1 - 21

ex) 1.1 - 22

# 가우스 소거법
- 행 사다리꼴(REF) : 아래 특징을 만족하는 행렬
    prop : 성분이 모두 0이면 가장 아래
           처음 나타나는 0이 아닌 성분은 1
           아래 행의 같은 열에 1이 있으면 위쪽의 1은 더 왼쪽에 있어야 한다
    comment : 무슨 짓을 해서라도 정확하고 빠르게 이걸 구할 수 있도록 해라
- 기약 행 사다리꼴(RREF) : REF에서 1의 위쪽을 최대한 0으로 만든 행렬
- 가우스 소거법 : 첨가행렬을 REF로 바꿔서 후진대입으로 해집합을 구하는 방법
- 가우스-조단 소거법 : 첨가행렬을 RREF로 바꿔서 해집합을 구하는 방법
    comment : RREF를 통해 구하라고 하면 진짜 RREF까지 만들어야 함
    cf. 매개변수의 수는 해집합의 차원. 
        다만, 그것이 해집합에 있는 해의 차원을 나타내는 것은 아님. 매개변수의 수와 관계가?
- 동차 연립방정식 
    prop : 자명한 해(x = 0)를 가짐.
    app : 동차 연립방정식에 대해 알면 비동차도 좀 할 수 있는데, 
          자명한 해를 가지는 동차에 대해 비동차로 바꿨을 때 해의 존재를 알 수 있음

TODO
ex) 1.2 - 8
ex) 1.2 - 11
ex) 1.2 - 17
ex) 1.2 - 29
ex) 1.2 - 30
ex) 1.2 - 34
ex) 1.2 - 36
ex) 1.2 - 37

# 행렬과 행렬의 기본 연산
- 행렬 : 수를 직사각형 모양으로 배치한 것
    notation : only [] or (). 다른거 절대 안 됨  
               행렬은 A, 원소는 aᵢⱼ로 표기
               A = [aᵢⱼ]ₘ ₓ ₙ
- 행, 열 백터 : 가로, 세로줄
    notation : aᵢ(i열 백터). 행백터는 보통 그 전치 형태로 표현
- 주대각선성분(diagonal element) : 말 그대로 대각선대 있는 원소
- 행렬의 상등 : 진짜 모든 원소가 같아야 힘
    caution. 열과 행이 바뀌면 안 됨. 다른 거임
- 계수행렬(coefficient matrix) : 계수 가져다가 만든 행렬
    notation : x₁a₁ + ... xₙaₙ = b
               Ax = b
- 행렬의 곱
    AB = [cᵢⱼ]ₘ ₓ ₙ
    method : 첫 번째 행렬의 i번째 행의 원소들에 두 번째 행렬의 j번째 원소들을 더하고 곱해 cᵢⱼ를 표기
    prop : 교환법칙 성립하지 않음
           이산수학에서 그 그래프 경로와 관련된 문제에 활용할 수 있음
           첫 번째 행렬의 열의 수와 두 번째 행렬의 행의 수가 같아야 함. 
           연산 후 결과는 앞의 행, 뒤의 열의 수를 따름
    comment : 곱하기 쓰지 말고 그냥 축약해서 써라

ex) 
- A -> B 항공편이 있고 B -> C 항공편이 있을 때, A -> C의 경로를 구하여라
-> sol) 인접 행렬과 비슷하게 함

A -> B  B -> c
2 0 1    1 2
1 0 0    1 0
         3 0

이렇게 있을 때, 곱하면 그냥 갈 수 있는 경로가 나옴

TODO 
ex) 1.3 - 10
ex) 1.3 - 14
ex) 1.3 - 17
ex) 1.3 - 18

# 행렬 연산의 성질
- 덧셈 : 교환법칙, 결합법칙이 성립
- 곱셈 : 결합법식, 분배법칙 성립
- 단위행렬(identity matrix) : 주대각선성분이 1, 나머지가 0
    notation : Iₙ
    ex : AB + A = A(B + I)
- 거듭제곱: 
    A⁰ = Iₙ
    Aᴷ = AA...A <- k번 제곱, A는 반드시 정사각행령
    prop : -1과 0을 포함함 자연수의 거듭제곱만 정의되어 있음. 
           음수나 유리수만 아니면 지수법칙 성림
- 추가 성질
    (A + B)² != A² + 2AB + B²
    (A + Iₙ)² = A² + 2A + Iₙ
    (AB)² != A²B²
    AB = 0일 때, A = 0 or B = 0은 아니다  
    A != 0인데 A² = 0일 수 있다. k제곱에 대해서도 성립
    AB = B라도 A = 0은 아니다
    AB = AC라도 B = C는 아니다
- 역행렬(inverse matrix) : 정사각행렬 A에 대해 곱해 Iₙ가 되는 것
    notation : A⁻¹
    prop : AB = Iₙ = BA
           역행렬은 유일하다
           (A⁻¹)⁻¹ = A
           (AB)⁻¹ = B⁻¹A⁻¹. -> (ABC)⁻¹ = C⁻¹B⁻¹A⁻¹
           (kA)⁻¹ = (1/k)A⁻¹
           (Aᴷ)⁻¹ = (A⁻¹)ᴷ
    caution. 절대 행렬이 분모에 들어가면 안 됨(나누면 안 됨)
             A⁻ᴷ으로 절대 쓰면 안 됨(k != 1)
- 가역행렬(invertible matrix) : 역행렬이 존재하는 행렬
- 비가역(noninvertible matrix) : 역행렬이 존재하지 않는 행렬
    ex. 어떤 행렬의 모든 행이 모두 0이면 1을 만들지 못해 비가역행렬이 된다
- 2 * 2 행렬의 역행렬 (공식 존재):
    A = [[a, b], [c, d]]
    -> (1 / (ad - bd)) * [[d, -b], [-c, a]]

TODO
ex) 1.4 - 8
ex) 1.4 - 12
ex) 1.4 - 15
ex) 1.4 - 17

# 기본행렬은 이용한 역행렬 계산
- 기본행렬 : 단위행렬 Iₙ에 기본행연산 1번만 한거
    notation : Eᵢⱼ, Eᵢ(c), Eᵢⱼ(c)        
               Iₙ Eᵢⱼ~ Eᵢⱼ
               -> 여기에서 괄호 위에 있는 것은 기본행연산, 관로 오른쪽에 있는건 기본행렬
    app : 행렬의 앞쪽(왼쪽)에 곱하여 REF 만듦. ex. E₁₂ E₁(4) ... E₁(3) A
    caution. 반드시 왼쪽에 곱함. 가장 마지막에 한 것이 가장 왼쪽에 옴
- 기본행렬의 역행렬:
    Eᵢⱼ⁻¹ = Eᵢⱼ            
    Eᵢ(c)⁻¹ = Eᵢ(1/c)
    Eᵢⱼ(c)⁻¹ = Eᵢⱼ(-c)⁻¹
    caution. 여기의 우항은 Iₙ를 기본행연산 한 것임. 좌항이 아니고
- 역행렬 만드는 방법
    1. [A | Iₙ]을 만듦
    2. [A | Iₙ]의 RREF를 구함
    3. 그 결과 [RREF | D]라고 하면, D = A⁻¹임
    4. 왼쪽 행렬이 RREF가 안 되면, A는 비가역행렬임
    caution. 마지막에 나온 역행렬을 원래 행렬 A와 곱하여 I가 나오가 확인좀 하기
- 모든 가역행렬은 기본행렬의 곱으로 표현될 수 있음

TODO
ex) 1.5 - 11
ex) 1.5 - 15
ex) 1.5 - 16

# 역행렬을 이용한 연립일차방정식의 풀이
- 해 존재성 : Ax = b일 때, x = A⁻¹b로 정의. 
    prop : 유일한 해임
           -> 저런 식으로 표시가 성립한다면, 역행렬이 존재한다
    caution. 좌항과 우항에 모두 A⁻¹를 "왼쪽"에 곱합

ex) 02
x1      + x3 = b1
x1 + x2 + 2x3 = b2
2x1 + x2 + 3x3 = b3일 때, 역행렬 존재 여부
[1 0 1] | [1 0 0]
[1 1 2] | [0 1 0]
[2 1 3] | [0 0 1]
-> RREF로 만들어봄. 만들어지면 존재

TODO
ex) 1.6 - 8a 
ex) 1.6 - 11a 
ex) 1.6 - 10a

- 전치행렬(transpose matrix) : 행을 열로 바꾼 행렬
    prop : (Aᵀ)ᵀ = A
           (AB)ᵀ = BᵀAᵀ
           (A + B)ᵀ = Aᵀ + Bᵀ
           (kA)ᵀ = kAᵀ
           (Aᵀ)⁻¹ = (A⁻¹)ᵀ
    comment : 이거 증명을 낼 수도 있는데, 예시를 들면 안 되며, 일반적인 경우에 대해 증명해야 함
- 대칭행렬(symmetric matrix) : Aᵀ = A인 행렬 A
- 반대칭행렬(skew-symmetric matrix) : Aᵀ = -A인 행렬 A
    caution. 대칭행렬은 반드시 정사각행렬일 때만 논의될 수 있음
- 상삼각행렬(upper-triangular matrix) : 위쪽에 0이 아닌 원소가 있는 것
- 하삼각행렬(lower-triangular matrix) : 아래쪽에 0이 아닌 원소가 있는 것
- 대각행렬(diagonal matrix) : 대각선 원소만 빼고 모두 0인 행렬
- 대각합(trace) : 그냥 대각선 값 다 구함
    notation : tr(A)
    caution. 정사각행렬일 때만 
    prop : tr(A + B) = tr(A) + tr(B)
           tr(AB) = tr(BA)

TODO
ex) 1.7 - 13 
ex) 1.7 - 17 
ex) 1.7 - 25


chapter 02

# 행렬식
- 행렬식 : 행렬이 가리키는 scale
    계산 prop:
           |Aᵀ| = |A|
           A에서 두 행 혹은 열을 바꾼 행렬 B에 대해 |A| = -|B|             (기본행연산 1번)
           두 행 혹은 열이 같으면 |A| = 0
           한 행 혹은 열에 k배를 한 행렬 B에 대해 |B| = k|A|              (기본행연산 2번)
           한 행/열에 k배를 하여 다른 행/열에 더한 행렬 B에 대해 |B| = |A|    (기본행연산 3번)
           det(AB) = det(A)det(B)                                  단, A와 B는 같은 크기의 정사각행렬. comment 간단증명
    이외 prop:
        행렬식이 0이 아니면 역행렬 존재
        det(A⁻¹) = 1 / det(A)
        유일한 해를 가진다 -> det(A) = 0이다
    notation : |A| or det(A)
- 사루스 : 2 * 2 or 3 * 3에 대해서만 가능
    a13 a11 a12 a13 a11
        a21 a22 a23
    a33 a31 a32 a33 a31
    이렇게 해서 오른쪽 아래로 세 개는 +, 왼쪽 아래는 -로 묶어서 더함

TODO
ex) 2.1 - 15 
ex) 2.1 - 28 
ex) 2.1 - 32 
ex) 2.1 - 36 
ex) 2.1 - 39

# 여인수 전개와 크래머 공식
- 소행렬식(minor) : i행과 j열을 제외한 행렬
    notation : Mᵢⱼ
- 여인수(cofactor) : (-1)ⁱʲ * Mᵢⱼ
    notation : Aᵢⱼ
- 여인수 전개 : 하나의 열/행을 잡고 aᵢⱼ * Aᵢⱼ을 함. 하나의 행/열에 대해서만 하면 됨
- 수반행렬(adjoint matrix) : Aᵢⱼ들을 쭉 자리에 맞게 배열하고 전치시킨 행렬
    notation : adj(A) = [Aᵢⱼ]ᵀ
    prop : A * adj(A) = |A| * Iₙ                                    옳은 여인수 전개만이 값을 가지니 대각선성분만이 값을 가질 수 있기 때문
           A⁻¹ = (1/|A|) * adj(A)                                   이거 식 변형해서 많은거 만들 수 있음
           adj(AB) = adj(B)adj(A)
    comment : 가역행렬에 대한 동치 명제를 굉장히 빠르게 잘 활용해야 한다.
- 크래머 공식(cramer's role) : 하나의 미지수만 뽑아낼 수 있는 공식
    method : xᵢ = |Mᵢ|/|A|
            Mᵢ = Ax = b꼴의 연립일차방정식일 떄, i번째 열을 b행렬로 바꿔치기하여 구한 행렬식

TODO
ex) 2.2 - 7 
ex) 2.2 - 9 
ex) 2.2 - 17 
ex) 2.2 - 22


chapter 03

# 백터
- 백터 : 시작, 끝, 방향이 있음
    caution. 같다고 표기하려면 세 요소가 다 같아야 함
    notation : v = (x, y)                        (x, y는 종점 - 시점으로 표시함)
- 스칼라 : 그 크기만 나타내는 것. 방향이 없음
- 음백터 : 크기가 같고 방향이 다른 백터
- 노름(norm) : 백터의 크기
    notation : ||v||
    method : √(v₁² + v₂²...)
    prop : 노름이 0이면 영백터

ex) 
v = (5, -3, 1)
1. 단위백터화 -> v / ||v||        (세 수 각각에 나눔)
2. 방향 바꿈 -> -v                (세 수 각각에 곱합)

- 표준단위백터 : (1, 0, 0), (0, 1, 0)과 같은 것들

TODO
ex) 3.1 - 15 
ex) 3.1 - 19 
ex) 3.1 - 21

# 백터의 내적
- 내적(inner, scalar, dot product) : ||u|| * ||v|| * cosθ = u₁v₁ + u₂v₂
    prop : 결과물은 스칼라
    comment : ||u|| * ||v|| * cosθ를 보고 저것과 u₁v₁ + u₂v₂이것이 왜 같은지 유도할 수 있어야 함 (미적분에서 했던 반각법칙이 여기에...)ec---------------- 여기까지 1차 퀴즈 ------------------------, scross product)
    






    









