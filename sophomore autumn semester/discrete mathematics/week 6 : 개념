1. lean4 원본 주고 골격 빈칸 체우기
2. 정의 쓰기 
3. 행렬 det, 여인수, 계산하기, 역행렬 
4. 증명
5. lean4를 보고 증명 하기 



# operators

함수/증명 구조
- λ : \lam / 람다 (익명 함수)
- ⟨ ⟩ : \langle, \rangle / 쌍 (pair, angle bracket)
- ⊢ : \vdash / 턴스타일 (provable)

# Lean tactics
rfl 
- reflexivity(반사성) : 좌변과 우변이 동일하다라는 사실을 자동으로 증명하는 전술.
- 정의적 동일성(definitional equality)만 인정한다.
- 복잡한 식, 중간에 다른 정리가 필요한 경우에는 실패한다.
- 강력하지만 제약이 많음

rw
- 등식(=) 또는 논리 동치(↔) 정리 h를 사용해서 현재 목표(goal) 안의 어떤 부분을 치환
- 반드시 대활호 안에 증명 이름이 들어가야 함
- rw [add_comm b c] : b + c를 c + b로 치환해라 (항을 뒤집는다)
- rw [add_zero] : 0이 더해져 있는 부분을 없애줌
- rw [h1, h2, h3] : 순서대로 차례차례 적용
- rw [h] at ⊢ : 목표 전체 (기본 동작)
- rw [h] at H : 특정 가정
- rw [h] at * : 모든 가능한 곳에 다 적용

ring
- 대수적 구조를 이용하여 자동적으로 처리해준다
- 등식 정리에 활용함

by
- by 뒤에 오는 것으로 전술을 하겠다

extract
- 존재 한정자(∃) 나 조건부 존재 증거를 꺼내올 때 사용
- 즉, “존재한다”는 말을 “이게 그 존재하는 값이야!”로 바꿔주는 도구


chapter 0

# 명제
- 변수(variable) : 아직 값을 모르는 대상을 가리키는 기호
- 보편명제(universal statement) : 한 집합의 모든 원소에 대해 성질이 참
    ex. 모든 양의 수는 0보다 크다
- 조건명제(conditional statement) : if ~, then ~ 꼴
    ex. n이 18로 나누어떨어지면, 6으로도 나누어떨어진다
- 존재명제(existential statement) : 적어도 하나가 있다
    ex. 짝수인 소수가 존재한다
- 보편•조건명제(universal conditional statement) : 보편성과 조건을 함께 가진 명제
    ex. 모든 동물 a에 대해, 만약 a가 고양이라면, a는 포유류이다
- 보편•존재명제(universal existential statement) : 앞부분은 보편, 뒷부분은 존재
    ex. 모든 냄비에는 뚜껑이 있다
- 존재•보편명제(existentail universal statement) : 앞부분 존재, 뒷부분 보편
    ex. 모든 양의 정수보다 작거나 같은 양의 정수 m이 존재한다


# 집합
- ℤ⁺ : positive intergers

- 부분집합(subset) 
    정의 : A ⊆ B ⇔ ∀x (x ∈ A → x ∈ B) 
    풀이 : 모든 x에 대해 x가 A에 속해 있으면 B에도 속한다 | 이건 ∈과 다르게, {2} ⊆ {1, 2, 3} 이런식으로 집합끼리 비교, 참고로 ∈는 2 ∈ {1, 2, 3}이 맞는 표현
    기호 : ⊆
- 진부분집합(proper subset)
    정의 : A ⊊ B ⇔ (A ⊆ B) ∧ (∃x (x ∈ B ∧ x ∉ A)) 
    풀이 : A가 B의 부분집합일 때, B에 속하고 A에 속하지 않는 어떤 x가 존재한다
    기호 : ⊊


chapter 1 (수의 표현과 연산)

# 수 체계
- ℕ : # check nat / 자연수 
- ℤ : # check int / 정수
- ℚ : # check rat / 유리수
- ℝ : # check real / 실수
- ℂ : # check complex / 복소수

- 기수(base) 아래첨자(오른쪽)로 진법 표현
    0b(2진수), 0o(8진수), 0x(16진수), 그냥(10진수)

- Lean
-------------------------------------------------------------------

ex.1 (기수 계산)
def digit_expansion(a2 a1 a0 base : Nat):
    Nat := a2 * base^2 + a1 * base^1 + a0 * base^0 
#eval digit_expansion5 8 9 10

-------------------------------------------------------------------

ex.2 (복소수 연산)
import Mathlib.Data.Complex.Basic
open Complex
variables{a b c d: ℝ}  
#check I -- 복소수 I를 바로 쓸 수 있게 만들어줌

#eval (Complex.mk ab) + (Complex.mk c d)  --(a + c) + (b + d) * I
#eval (mk ab) - (Complex.mk c d)  --(a - c) + (b - d) * I
#eval (mk ab) * (Complex.mk c d)  --(a * c - b * d) + (a * d + b * c) * I
#eval (mk ab) / (Complex.mk c d)

-------------------------------------------------------------------


# 수 계산
- 닫혀있다(closed) : 해당 수 체계끼리 연산하여 해당 수 체계가 나오지 않는다
    ex : 자연수를 자연수로 나누면 자연수가 나오지 않을 수 있음 -> 자연수는 나눗셈에 대해 닫혀있다
- 항등원(identity element, 연산해도 같아지는 것)
    덧셈 :  0
    곱셈 : 1
- 역원(inverse element, 연산하여 항등원이 되는 것)
    덧셈 : -a
    곱셈 : 1/a
- 하한항(lowest) : 기약분수
- 합 연산 : ​∑​ (sigma)
    아래 Lean 사용법 봐야 함, 성질은 다 아니 skip
- 곱 연산 : Π (product)
    공집합 : 곱할 항이 하나도 없으면 0
    상수항의 곱 : Π(i = 1 ~ n) c = c^n
    곱 분할 : Π(i = i ~ n) xi * yi = Π(i = 1 ~ n) xi * Π(i = 1 ~ n) yi
    범위 나누기 : Π(i = 1 ~ n) xi = Π(i = 1 ~ k) xi * Π(i = k + 1 ~ n) xi
- 나누기 연산 유용한 정리
    d|m이고, d|n이면, d|(m + n) and (m - n)
    ...(너가 아는거)

- Lean
-------------------------------------------------------------------

ex.1 (덧셈의 교환법칙 증명 by 수학적 귀납법)
import Mathlib.Data.Complex.Basic

example (a b : N) : a + b = b + a :=
begin
    induction b with d hd, -- b에 대해 수학적 귀납법 시작, 1단계 : b = 0
    rw Nat.add_zero,
    rw Nat.zero_add,
    rfl

    -- 2단계 : 귀납가정(hd), b = succ d
    rw Nat.add_succ, 
    rw hd,
    rw Nat.succ_add,
    rfl
end

-------------------------------------------------------------------

ex.2 (덧셈의 결합법칙 증명 by 수학적 귀납법)
import Mathlib.Data.Complex.Basic

example (a b c : N) : (a + b) + c = a + (b + c) :=
begin
    induction c with d hd, -- c에 대해 수학적 귀납법 시작, 1단계 : c = 0
    rw Nat.add_zero,
    rw Nat.zero_add,
    rfl

    -- 2단계 : 귀납가정(hd), c = succ d
    rw Nat.add_succ, 
    rw hd,
    rw Nat.succ_add,
    rfl
end

-------------------------------------------------------------------

ex.3 (덧셈의 분배법칙 by 수학적 귀납법)
import Mathlib.Data.Complex.Basic

example (a b c : N) : (a + b) * c = a * b + a * c :=
begin
    induction c with d hd, -- c에 대해 수학적 귀납법 시작, 1단계 : c = 0
    rw Nat.add_zero,
    rw Nat.zero_add,
    rfl

    -- 2단계 : 귀납가정(hd), c = succ d
    rw Nat.add_succ, 
    rw Nat.mul_succ
    rw hd,
    rw add_assoc, -- 결합법칙 적용
    rfl
end

-------------------------------------------------------------------

ex.4 (∑​(i = 1 ~ n) c = n * c | 상수의 합 증명)
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Real.Basic
open Finset
variable {n: ℕ} {c : ℝ}

example: (sum(range n) (λ _ => c)) = n * c :=
by rw[sum_const, Nat.card_range, mul_comm]

-- 주의점 : 6, 7번째 줄의 sum, range, sum_const는 Finset이라는 네임스페이스에 기반하여 있기 때문에 반드시 open Finset을 해줘야 함
-- 참고 : range n은 0 ~ n - 1까지인데, 여기서는 c만 정의되어 있어 횟수만 중요하기 때문에 상관없음
-- sum_const : 상수함수의 합 정리. 즉, 이미 되어 있는 정리를 사용하여 증명할 것임.
--     (range n).card * c로 먼저 변함. n * c와 정확히 같지 않기 때문에 다음 정리들이 필요
-- Nat.card_range : (range n).card = n 
--     range n의 원소 수는 n과 같다는 것이 자명. 따라서 (range n).card를 n으로 바꿔줌
--     이후, n * c로 바뀔 것 같지만, sum_const가 scalar multiplication이라 c가 앞에 옴
-- mul_comm : 곱셈의 교환법칙, c * n을 n * c로 바꿔줌

-------------------------------------------------------------------

ex.5 (∑(i = 1 ~ n) c * xi = c * ∑(i = 1 ~ n) xi | 상수배의 합 증명)
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Real.Basic
open Finset
variable {x: ℕ → ℝ} {n: ℕ} {c : ℝ}

example: (sum(range n) (λ i => c * x i)) = c * sum(range n) x:=
by rw[sum_mul]

-- sum_mul : 합 오른쪽에 곱이 있을 때 곱을 빼냄. 여기서는 mul_sum이 더 직접적. 상관은 없는 듯

-------------------------------------------------------------------

ex.6 (∑(i = 1 ~ n) xi + yi = ∑(i = 1 ~ n) xi + ∑(i = 1 ~ n) yi | 합의 분배 증명)
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Real.Basic
open Finset
variable {x: ℕ → ℝ} {y : ℕ → ℝ} {n: ℕ}

example : (sum(range n) (λ i => x i + y i)) = sum(range n) x + sum(range n) y :=
by rw[sum_add_distrib]

-- Finset.sum_add_distrib : ∑ x in s, (f x + g x) = (∑ x in s, f x) + (∑ x in s, g x)
-- 이건 그냥 있는 정리를 이용해서 한 번에 끝냈음

-------------------------------------------------------------------

ex.7 (∑(i = 1 ~ n) xi = ∑(i = 1 ~ k) xi + ∑(i = k + 1 ~ n) xi | 합의 분할 증명)
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Real.Basic
open Finset
variable {x: ℕ → ℝ} {n: ℕ} {k : ℕ} (h : k < n)

example :(sum(Icc 1 n) x) = sum(Icc 1 k) x + sum(Icc(k + 1) n) x :=
by rw[sum_Icc_add_sum_Ico_eq_sum_Icc (by linarith) (by linarith)]

-- Icc a b : 자연수의 닫힌 구간 {i ∣ a ≤ i ≤ b}
-- Ico a b : 자연수의 반열린 구간  {i ∣ a ≤ i < b}
-- sum_Icc_add_sum_Ico_eq_sum_Icc :
--     a ≤ k + 1 → k + 1 ≤ b + 1 →
--     ∑ i in Icc a b, f i = (∑ i in Icc a k, f i) + (∑ i in Ico (k + 1) (b + 1), f i)
--     합의 분할 증명. 그냥 있는거 썼음, 구간에 대한 전제조건을 요구함
-- by linarith : 위의 정리를 쓰려면 구간이 올바르게 잡혔다는 선행 부등식 필요.
--     각각이 1 ≤ k + 1, k + 1 ≤ n을 차례로 증명해줌

-------------------------------------------------------------------

ex.8 (d | m, d | n → d | (m+ n), d | (m-n) / 나누어떨어짐 증명)
import Mathlib.Data.Int.Basic
open Int 

example(d m n: ℤ) (hm: d ∣ m) (hn: d ∣ n) : d ∣ m + n:=
by
obtain⟨k, rfl⟩ := hm 
obtain⟨l, rfl⟩ := hn 
use k + l 
ring

-- (hm: d ∣ m) -> d가 m의 약수이다, 어떤 수 k에 대해 m = d * k이다
-- obtain⟨k, rfl⟩ := hm -> 위의 어떤 수 k를 여기서 쓰는 k로 치환. 내부적으로 d = m * k로 취급
-- use k + l -> m + n = d * t일 때, t의 값에 k + l를 쓴다는 뜻. use는 "존재하는 값을 제시하라"는 전략
-- ring 덧셈 분배법칙 (간단한 대수적 정리) 자동증명, 등식정리

-------------------------------------------------------------------

ex.9 (d|m -> d|m * n 증명)
import Mathlib.Data.Int.Basic
open Int 

example(d m n: ℤ) (hm: d ∣ m) : d ∣ m * n := 
by 
obtain⟨k, rfl⟩ := hm

-- 어떤 k가 존재함을 확인하여 증명 끝
-- by를 쓰면 rfl을 안 써도 이 by로 끝낸다는 뜻

-------------------------------------------------------------------


# 진법 표현
- 기수(Base) : 수 표현의 기준
- 올림수(Carry) : 더하기 할 때 1 올리는 그거
- 빌림수(Borrow) : 피감수 < 감수일 때 윗자리에서 1을 빌림
- 진법 변환
    10진수 to others
        정수부 : 몫이 0이 될 때까지 변환하려는 기수로 나누면서 각 단계의 나머지 나열
        실수부 : 소수부가 0이 될 때까지 변환하려는 기수로 곱하면서 각 단계의 정수부 값 나열. 정수부 값은 바로 버림
    others to 10진수
        해당 기수^n을 자릿수마다 곱하면서 나오는 모든 값의 합
    2진수 to 8/16진수 and 8/16진수 to 2진수
        2 to 8/16 : 8진수는 2진수의 3자리씩 끊어서 수로 변환, 16진수는 4자리씩
        8/16 to 2 : 한 자리를 3, 4자리씩 2진수로 바꿔 배정시키면 됨
- 보수(complment) : 어떤 k진수 a에 대한 n의 보수는 a와의 합이 nnn...이 되는 수
    n진수에서는 n의 보수, n - 1의 보수가 있음
    ex. 2진수 보수는 전체를 toggle한 값


# 컴퓨터에서의 수 표현
- 워드(word) : 컴퓨터 아키텍쳐에 따라 8비트 컴퓨터이면 8비트, 16비트 컴퓨터이면 16비트가 됨
- 부호-절댓값 표현 (sign–magnitude) : 가장 왼쪽을 부호 비트로 두고 나머지로 수를 표현
    10진수 변환 : 그냥 하면 됨
- 부호-1의 보수 표현 (sign–1’s complement) : 양수는 그대로 모든 비트에 표시하고, 음수는 반전해서 표현
    부호-1의 10진수 변환 : 가장 앞 비트가 0이면 그대로 변환, 1이면 반전시켜서 음수로 변환
    초과한 값 : 구한 값에 초과한 값 더함
- 부호-2의 보수 표현 (sign-2's complement) : 양수는 그대로 두고 음수는 반전시키고 +1한 값(2의 보수)로 표현
    부호-2의 10진수 변환 : 가장 앞 비트가 0이면 그대로 반환, 1이면 2의 보수를 음수로 반환
    초과한 값 : 무시


chapter 2 

# 논리연산자
- ¬ : 부정 (not)
- ∧ : 논리곱 (and)
- ∨ : 논리합 (or)
- ↔ : 동치 (iff) / inverse exclusive or
- → : 함의 (implies)
- exclusive or : only T F일 때면 F

- 역 : p -> q일 때, q -> p
- 이 : p -> q일 때, ~p -> ~q
- 대우 : p -> q일 때, ~q -> ~p

- 우선순위 : ~ -> ^ -> v -> → -> ↔

- 항등법칙 : T와 F에 ^, v를 했을 때 항상 같아짐
- 지배법칙 : T와 F에 v, ^를 했을 때 T, F가 됨
- 부정법칙 : p ^ ~q = F | p v ~q = T
- 이중부정법칙 : ~(~p) = p
- 멱등법칙 : p ^ p = p | p v p = p
- 교환법칙 : p ^ q = q ^ p | p v q = q v p
- 결합법칙 : (p ^ q) ^ r = p ^ (q ^ r)
- 분배법칙 : p v (q ^ r) = (p v q) ^ (p v r)
- 드모르간법칙 : ~(p ^ q) = ~p v ~q
- 흡수법칙 : p ^ (p v q) = p
- 함축법칙 : p -> q = ~p v q

p ^ (p v q) 
= (p v F) ^ (p v q) (항등)
= p v (p ^ F) v (F ^ q) (분배)
= p v F v F (지배법칙)
= p (항등법칙)


- Lean
-------------------------------------------------------------------

ex.1 ((p -> q) ↔ (~p v q) 증명)
example(p q : Prop) : (p → q) (¬p ∨ q) := 
by 
apply Iff.intro  
·intro h
by_cases hp : p
· exactOr.inr(hhp)
· exactOr.inl hp
· intro h hp 
cases h with
| inl hnp => contradiction
| inr hq => exacthq

-------------------------------------------------------------------

ex.2 (((p -> q) ^ (p -> ~q)) ↔  ~p 증명)
example(p q : Prop) : ((p → q) ∧ (p → ¬q)) ¬p := 
by
constructor
· intro h hp 
    have h1 : q := h.left hp
    have h2 : ¬q := h.right hp
    exact h2 h1
· intro h 
    constructor
    · intro hp; contradiction
    · intro hp; contradiction

-------------------------------------------------------------------

ex.3 ((p → q) ∧ (p → ¬q) ↔ ¬p, 모순법칙 증명)
theorem imp_and_impnot_iff_not_skel (p q : Prop) :
  (p → q) ∧ (p → ¬q) ↔ ¬p :=
by
  constructor
  · intro h
    intro hp
    -- h.left : p → q
    -- h.right : p → ¬q
    -- p가 참이면 q와 ¬q가 동시에 참이 되어 모순
    (have hq :=) h.left hp
    (have hnq :=) h.right hp
    (exact hnq hq)
  · intro hnp
    constructor
    · intro hp
      (exact) False.elim (hnp hp)
    · intro hp
      intro hq
      (exact) False.elim (hnp hp)

-- ()안이 빈칸

-------------------------------------------------------------------

ex.4 (p ∨ p ↔ p, 멱등법칙 증명)
theorem or_idem_skel (p : Prop) : p ∨ p ↔ p :=
by
  constructor
  · intro h
    cases h with
    | inl hp => exact hp
    | inr hp => exact hp
  · intro hp
    exact Or.inl hp

-------------------------------------------------------------------


# 명제함수와 제한자
- 명제함수(propositional funtion) : 논의영역이 주어진 변수 x를 포함하여 진릿값을 판별할 수 있는 문장이나 수식 / P(x)
- 논의영역(domain of discource) : 명제함수에 포함된 변수 x의 범위나 값 / D
- 전체 한정자 : ∀, 모든 (for all)
- 존재 한정자 : ∃, 존재 (there exists)

- 한정자와 논리연산자
    ∀과 ^ -> 분배 가능
    ∀과 v -> 분배 불가능
    ∃과 v -> 분배 가능
    ∃과 ^ -> 분배 불가능


# 추론
- 유효추론 : 참인 전제를 이용한 결론이 모두 참인 결론
    ex. 전제 : p -> q (T)
              p (T)
              결론 : T
- 허위추론 : 참인 전제를 이용한 결론이 거짓인 추론
    ex. 전제 : p -> q (T)
              p (T)
              결론 : F
    위의 케이스가 하나라도 있으면 허위추론임
- 긍정논법(modus pponens) : given p -> q and p is true. thus, q is true. 
     ex. 만약 비가 오면, 길이 젖는다.
        비가 오고 있다.
        따라서, 길이 젖었다
- 부정논법(modus tollens) : given p -> q and q is false. thus p is false.
    ex. 만약 개가 침입자를 감지하면, 개가 짖을 것이다.
        개가 짖지 않았다.
        따라서 개는 침입자를 감지하지 못했다.
- 선연적삼단논법(disjunctive syllogism) : one of p and q is true. and p is false. thus, q is true
- 추론 : 전제가 모두 참이라고 가정하고 결론이 T가 나오면 유효, 아니면 허위로 알아서 계산하셈


chapter 3

# 증명법
- 직접 증명법 : 조건명제 p -> q, p가 참이면 q도 참임을 증명
- 간접 증명법
    모순 증명법 : p -> q를 p ^ ~q가 거짓임을 보여 증명
    대우 증명법 : p -> q를 ~q -> ~p가 참임을 보여 증명
    존재 증명법 : 명제가 참이 되는 예를 찾아 증명 (어떤 ~~에 대해에 쓰임)
    반례 증명법 : 반례찾기~ 반례찾기~
- 수학적귀납법 : 0보다 크거나 같은 정수 범위에서 발생하는 일정한 규칙을 나타내는 명제가 성립함을 증명
    우선 시작점에서 성립함을 보임.
    n에서 성립한다고 가정하고 그것이 n + 1에서 성립함을 보임


chapter 4

# 집합
- 유한집합 : 유한개 집합
- 무한집합 : 무한개 집합
- 집합 표기법  
    원소나열법 = {1, 3, 4, 5, 3}
    조건제시법 = {x | 1 < x < 3}
    벤다이어그램 = 그림 그거
- 기수 : 집합 A에 포함된 원소의 수

# kind of set
- 전체집합(universal set : U) : 모집단인듯
- 상등 : 전체 원소 모두 같음
- 서로소 : 공통 원소 없음
- 대칭차집합 : A와 B의 합집합에서 교집합을 뺀 것
- 곱집합 : 행렬곱셈 비슷
    A = {1}
    B = {1, 2}
    A x B = {{1, 1}, {1, 2}}

# 집합의 대수법칙
- 다른건 다 위의 부울대수와 같음
- 보법칙 : A U A바 = U / A 교 A바 = 공집합
- 이중 보법칙 : A바바 = A

# 집합의 분할
- 분발 : 공집합이 아닌 집합을 서로소이면서 공집합이 아닌 하나 이상의 부분집합으로 나누는 것
- 집합류 : 분할된 부분집합



