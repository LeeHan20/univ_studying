chapter 07

# min cut, max flow
- G(V, E) : 유량 네트워크를 나타내는 방향그래프
- capacity(용량) : 얼마나 흘러보낼 수 있느냐
    notation : c(e)
- flow(유량) : 지금 얼마나 흐르고 있느냐
    notation : f(e)
- s-t cut : s, t를 포함하는 두 개의 그룹 A, B로 나누는 것
    notation : cut(A, B)
    prop : 최대 유량과 min cut은 같다
- value of capacity : A에서 B로 가는 모든 용량의 합. 근데 B에서 A로 가는 간선(방향성으로)의 용량은 집계하지 않음
    notation : cap(A, B)

ex) minimum cut problem
- find s-t cut of minimun capacity in given graph
-> sol) 1. 우선 조건은 두 A에서 B로 가는 간선들의 최소 용량을 구함
        2. 다 구한 후 시작점에서 유량이 남아있는 노드을 모두 연결하면 그게 min cut

- s-t flow : 유량은 용량보다 크면 안 되며, 들아가는 유량과 나가는 유량의 양이 같아야 한다. 만족하면 유량
- value of flow : s에서 얼마나 흘러나갔느냐
     notation : v(f)

ex) maximum flow problem
- find maximum flow in given graph
-> sol) using ford-fulkerson algorithm

- ford-fulkerson algorithm(포드-풀커슨):
    1. 경로 하나를 찾아서 최대 유량을 찾음
    2. 그 최대 유량만큼 G와 G_f에 표기
    3. 경로 찾는거(방향)은 G_f 따라서 찾으면 됨
    4. 이걸 계속 반복

# good augment path
- 생각해보면, ford-fulkerson에서 최악의 경우 최대 capacity만큼 반복을 함
- edmonds-karp algorithm: ford-fulkerson에서 path 찾는걸 bfs로 한거
    prop : 최단 경로로 먼저 가기 때문에 O(VE²)으로 처리 가능

# bipartite perfect matching
- goal : 이분 그래프에서 서로 겹치지 않게 짝을 짓는 최대 수
- 문제 변환
    1. s를 왼쪽 노드들과 모두 연결
    2. L과 R의 유량을 무한대로 하여 연결
    3. R을 t 와 모두 연결
    4. 뭐든 최대유량 알고리즘 돌림
- perfect matching : 말 그대로 모든 노드가 매치되는 것
- condition : 모든 부분집합 S에 대해 해당 노드에 인접한 노드의 집합을 N(S)라고 할 떄, |N(S)| ≥ |S|여야 함
- 시간복잡도:
    Ford-Fulkerson (DFS) : O(VE)
    Hopcroft-Karp : O(E√V)

# disjoint paths
- goal : 간선을 공유하지 않는 최대 경로의 수 (노드는 공유 가능)
- 문제 반환
    1. 모든 간선의 capacity를 1로 설정
    2. 그 후에 최대유량 구하면 그게 path의 수가 됨
- menger's thoerem(맹거의정리) : disjoint paths의 수는 s와 t의 연결을 끊기 위해 필요한 길의 수와 같다

# circulation with demands (수요 있는 순환) 
- s와 t가 모두 하나가 아닐 수 있다
- 정의 : 모든 node는 수요/공급 값 d(v)를 가짐
    -> d(v) > 0 : sink, t, 소비자
       d(v) < 0 : source, s, 공급자
       d(v) = 0 : 단순 경유지
- goal : 모든 수요와 공급이 채워지는 유량이 존재하느냐
- condi : 수요와 공급이 동일해야 함
- 문제 반환
    1. 모든 공급이 있는 점(d(v) < 0)을 연결하는 super source(s)를 만듦
    2. 수요도 동일하게 super sink(t)를 만듦
    3. 수요/공급이 있는 노드들과 super들과의 간선은 해당 수요/공급의 절댓값만큼의 capacity를 가지도록 함
    4. 최대 유량 구함
    5. 결과가 나온 그래프의 s에서 나가는 간선들이 꽉 찼다면(Saturated) 수요가 모두 만족된 것임

# circulation with demands with lower bounds
- 이번에는 간선에 2 이상은 무조건 흘러야 한다는 조건이 붙었음. 즉, 간선의 하한이 생김
- 생각해보면, 무조건 흘러야 한다는 것은 수요임. 시점의 입장에서는 양수의 수요, 종점 입장에서는 음수의 수요
- 문제 반환
    1. 하한이 있는 모든 간선에 대해 시점의 d(v)에 하한의 절댓값만큼 더함
    2. 종점의 d(v)에는 하한의 절댓값만큼 뺌
    3. 이렇게 수요/공급을 설정해놓고 다시 최대유량 돌림

ex) survey design
- 소비자들이 가진 물건이 주어지고 소비자들은 주어진 설문 횟수를 채워야 하며 제품은 설문을 받는 횟수를 채워야 함
-> sol) 기본적으로 lower bound circulation demands로 풀면 됨
        1. s, L(consumer), R(product), t에 간선을 연결함. L -> R은 capacity 1
        2. s -> L의 간선에 해당하는 설문 요구 횟수만큼 하한을 부여함. R -> t에도 마찬가지
        3. 하한을 수요/공금으로 치환
        4. t -> s인 capacity가 무한인 간선을 생성
        5. 최대 유량 돌려서 s에서 나가는 간선이 꽉 찼으면 설문조사 모델링 성공

# image segmentation
- 이미지는 배경과 전경으로 나눌 거임
- given : 각 픽셀의 전경 점수, 배경 점수(노드), 두 픽셀을 분리하였을 때의 패널티 점수
- goal : 나눈 배경/전경 점수 최대화, 패널티 점수 최소화
- 문제 반환
    1. 모든 노드에 대해 s, t와 연결함
    2. 간선의 capacity는 해당 전경/배경 점수임
    3. 바로 최대유량 구해서 mincut 구함
    4. 그렇게 두 부분으로 나누면 최적 전경/베경 구분됨

# project selection 
- goal : 비용, 이익이 있을 때 프로젝트 선택하여 이익 극대화
- given : 수행비용/이익, 선수 프로젝트
- 문제 반환 
    1. s를 이익, t를 비용이 드는 간선들과 연결 (이분 매칭같이)
    2. 프로젝트의 의존성 관계를 구성
    3. min cut 구함
    4. s에 속하는 집합이 수행했을 때 이익이 최대가 되는 집단, cut capacity가 최대 이익이 됨

# baseball elimination
ex)
- 경기에서 어떤 팀이 아직 (공동)우승 가능성이 남아있느냐
    한 번 이기면 1점을 획득함
    여러 팀이 여러 번 경기를 함
    어떤 팀 z의 (현재 점수) + (남은 라운드 수) = M이라고 함
-> sol) 1. s -> 남아 있는 경기들
            예를 들어, 1과 3의 경기가 4번 남았다면 s -> (1, 3)으로 용량이 4인 간선
        2. 경기들 -> 팀
            예를 들어, (1, 3)인 노드는 1팀과 3팀 노드에 영향을 줌. (1, 3) -> 1 and 3. 용량을 무한대로 설정. 누가 이겨도 상관없게 길을 열어둠
        3. 팀 -> t
            해당 팀은 z의 최대 점수인 M보다 크면 안 됨. 따라서 최대 M - (해당 팀의 현재 점수)만큼만 이겨야 함.
            따라서 팀 -> t의 용량은 M - (해당 팀의 현재 점수)이 됨
        4. 최대 유량 구함
        5. s에서 나가는 간선이 막혀있으면 z는 가능성 있음. 안 막혀있으면 우승 못 함


chapter 08

# polynomial-time reductions 
- reduction by equivalence : 수학적으로 같다면 환원할 수 있음

ex) independent set to vertex cover
- 두 문제가 서로 환원된다는 것을 보이시오
    independent set : 그래프에서 연결되어 있지 않은 노드들의 집합의 수를 세는 문제
    vertex cover : 해당 집합과 그에 연결된 간선을 모두 지우면 연결된 그래프가 없게 되는 노드의 집합을 찾는 문제
-> sol) 


- reduction from special case to general case : 일반적인 문제를 알 수 있으면 특수한 케이스도 풀 수 있음. 
    그에 따라, 어려운 정도와 쉬운 정도는 같음
    즉, 풀려는 문제보다 일반적인 경우가 증명되어 있으면 그걸 가져다 쓸 수 있다
- reduction via gadgets : 문제를 부분으로 나누어 다른 문제로 환원

# 3-SAT problem
- literal(변수) : X̄₁, X₂...
- clause(절) : 리터럴을 V(or)으로 묶은 것. 3-sat는 무조건 리터럴이 3개임
    notation : C₁ = (X̄₁ V X₂ V X₃)
- CNF(conjunctive normal form) : clause를 ∧(and)로 묶은 것
    notatton : Φ : C₁ ∧ C₂ ...
- goal : 각 리터럴에 적당히 0 or 1을 넣어서 Φ가 참이 되도록 할 수 있는가?
- prop : 다항 시간 내에 풀 수 있는 방법이 발견되지 않음. np-complete의 대표 예제

# Directed Hamiltonian cycle
- 문제 : 방향 그래프 G(V, E)에 대해 모든 정점을 한 번씩만 방문하고 다시 돌아오는 경로가 있느냐?
- 반환
    1. k개의 clause에 대해 literal의 수 만큼의 layer를 만들고, 각각의 layer는 3*(k + 1)개의 노드를 가짐
    2. s부터 x1으로 들어갈 때 정/역방향을 정해 x, X̄에 해당하는 clause에 방문할 수 있도록 간선을 이어 방문처리함
    3. cnf가 참이 된다면 헤밀턴 순환 존재

note1. 물론 그냥 구현할 수 있음. 근데 3-sat 문제로 치환시키는거임
note2. 모든 그래프의 헤밀턴 순환을 sat로 구할 수 있는게 아니고, sat를 만족할 때 대응하는 헤밀턴 순환이 있다는 것임

# 3-dimensional matching (from 3-sat three dimes matching)
- 문제 : n의 크기의 세 개의 집합 X, Y, Z를 섞은 임의의 T에 대해 겹치지 않는 {x, y, z}를 n개 뽑아서 X, Y, Z의 모든 원소를 다 덮을 수 있는가?
- 반환
    1. xn을 뽑아서 true or false unit으로 나눔
    2. 해당 literal은 clause의 수 k만큼의 true/false unit을 가짐
    3. 이제 걍 매칭을 함
    4. 근데 이제 literal이 3개라는 점에서 3d가 되는 거임
    5. 매칭이 되면 3-sat, 3dm 다 되는 거고 안 되면 안 되는 거임

note. 강의안의 그림은... 이게 무슨 이상한 그림인가 

# 3-colorability
- 문제 : 그래프를 r, g, b로 coloring 할 수 있느냐. 인접하지 않도록
- 반환
    1. X̄, X는 다른 색상을 가짐 (red or green)
    2. C = x, x, x일 때, 셋을 노드로 두고 이 셋과 이어져 있는 blue node를 설정
    3. 세 노드 아래에 2 * 3의 노드를 두고 [2][3]에서 green node는 [0][], [1][0]과 연결, red는 [1][2] 노드에 연결함
    4. x, x, x를 coloring하면 됨. 근데 clause가 여러 개일 때, 해당 x의 color는 전역적으로 관리됨
    5. 색칠되면 해결 안 되면 안 됨

# Subset sum
- 문제 : 자연수 집합이 주어졌을 때, 그 부분집합의 합이 목표값 T가 될 수 있느냐
- 반환
    1. subset에서의 numberic한 pick은 sat의 literal 진리값 설정과 비슷하다
    2. 또한 표를 만들어서 2진수로 숫자들을 놓고 선택하는 것에 대응하는 bit를 알 수 있다. 
    3. 그것에 맞춰 2⁰, 2¹... 위 자릿수 계산을 통해 10진수로 변환시킬 수 있다.
    4. 그리고 더미, complement, padding 등을 통해 1, 1, 1, 4, 4, 4(왜 4인지는 모름)을 맞췄을 때의 complement에는 10진수로 연산
    5. 해당 SAT가 만족된다면 이 subset sum 문제를 해결할 수 있다
    
















