시스템프로그래밍기초 12주차

이중 포인터
- 그냥 포인터를 또 포인터로 지칭한거임
int x = 20;
int *p = &x;
int* *dp = &p;

-> dp는 p의 주소만 보임 
  *dp(dp를 참조)하면 x의 주소를 알 수 있음
-> 그리고 *dp는 x의 주소만 보임
  **dp, *p을 하면 x의 값을 알 수 있음

동적할당
- heap영역에 할당
- 메모리 할당 요청 / 빈공간 확인 / 메모리 할당 / 메모리 반납
- 할당까지는 malloc()함수로 처리함 / calloc, realloc도 있음
- 반납은 free()로 함

malloc
- 괄호 안에 필요한 메모리의 크기를 입력받음
- 할당된 메모리의 주소(포인터)를 리턴함
- 해당 malloc함수의 리턴을 받은 포인터를 free함수에 입력하여 메모리를 반납함
- malloc함수는 포인터의 형식을 정해주지 않기 때문에(void pointer 리턴) 해당 포인터의 형변환을 할 필요가 있음
- 힙 영역에 여유메모리가 없다면 null을 리턴함
ex)
int *ptr;
ptr = (int*)malloc(sizeof(int));
-> ptr은 int가 아니고 int형 포인터이기 때문에 malloc함수의 리턴값을 int형 포인터로 형변환하여 할당

int *ptr;
ptr = (int*)malloc(3 * sizeof(int));
-> 배열과 같이 int형 메모리 3개를 할당받았기 때문에 ptr[2]까지 배열과 같이 사용 가능함
   대괄호를 이용한 참조, 포인터를 이용한 참조 모두 가능함

calloc
- clearing alloc
- malloc과 똑같이 할당함
- malloc은 쓰레기값을 할당하고 calloc은 0을 할당함
- 당연히 malloc보다 느림

realloc
- 원래 할당되었던 메모리에서 더 쓰고 싶을 때 사용
- realloc(pointer, 5 * sizeof(int))
- 입력받은 크기만큼 더 할당해줌

2차원 배열
- 니가 아는 그거
- 포인터로 선언할 수 있음
ex)
int (*ptr)[3];
-> 포인터를 통해 구현된 2차원 배열

int * ptr [3]
-> 포인터 배열

배열 포인터 변환
- 문자를 n개 가지는 배열을 가리키는 포인터를 m개 가지는 배열 arr
-> char, [n], *, [m], arr
   char (*[m]arr) [n]
   char (*arr [m]) [n]
대괄호를 기준으로 왼쪽에 있는 대괄호부터 넘어가고 왼쪽에 괄호를 만드는 방식을 반복하면
문법에 맞게 선언할 수 있음

배열 연산
- 배열의 이름(포인터 상수)는 배열이 요소로 가지는 것이 몇 바이트냐에 따라 +1 할 때 주소값이 바뀌는 정도가 다름
- 2차원 배열은 내부 배열의 크기에 따라 건너뛰는 바이트의 수가 결정됨

함수 포인터
- 함수의 이름도 포인터 상수
- (변환형)(*포인터 이름) (매개변수) = 함수 이름;

함수 포인터 변환
- int를 반환하고 매개변수가 없는 함수를 가리키는 포인터를 3개 가지는 배열 arr
-> int(), *, [3], arr
   int() (* [3] arr)
   int (*[3]arr)()
   int (*arr[3])()
소괄호, 대괄호를 싹 넘기면 선언할 수 있음

