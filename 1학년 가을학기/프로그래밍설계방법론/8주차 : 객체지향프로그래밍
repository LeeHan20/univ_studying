프로그래밍설계방법론 8주차

객체 지향의 특징 {
캡슐화
- 클래스 : 객체 모양을 선언한 틀(캡슐)
- 메소드와 필드를 클래스 안에 구현 
-> 객체 외부에서는 비공개 맴버(필드, 메소드)에 접근 못 함

상속
- 하위 개체가 상위 개체의 속성을 가짐
- 슈퍼 클래스의 속성을 사용하여 서브 클래스가 기능을 확장함
- 서브 클래스는 슈퍼 클래스 하나에게만 상속을 받을 수 있음
ex) 
class animal {
  int a;
  void eat() {...};
}

class human extends animal {
  int b;
  void study {...};
}
-> human은 animal의 필드(int a)와 메소드(void eat)를 사용할 수 있음

다형성
- 메소드 오버로딩 : 같은 이름이지만 다르게 작동하는 메소드들
- 메소드 오버라이딩 : 슈퍼클래스의 메소드를 서브클래스에 따라 다르게 작동하도록 구현

}


객체 지향의 목적
소프트웨어 생산성 향상
- 재사용하기 편함
- 부분 수정도 편함
- 다시 만들지 않아도 됨


절차/객체 지향 프로그래밍
- 절차 include 객체
- 절차 : 작업 순서를 표현 / 작업을 함수로 작성한 함수의 집합
- 객체 : 객체들간의 상호작용으로 표현 / 클래스 혹은 객체의 집합

클래스
- 객체를 만들기 위한 설계도 혹은 틀
- 객체의 행동(behavior)과 속성(state)를 포함

객체 
- 클래스 모양 그대로 찍어낸 실체
- 메모리 공간을 가지는 구체적 실체
- also called as instance

생성자
- 클래스 이름과 같은 메소드
- 객체가 생성될 때 자동으로 한 번 호출됨
- 생성자를 여러 가지로 작성 가능(오버로딩, 파라미터 등으로 구분)
- 리턴값 선언 불가
- 하나 이상 선언되어 있어야 함

기본 생성자
- 개발자가 생성자를 하나도 명시하지 않으면 원래 컴파일 오류
- but 컴파일러가 알아서 삽입하기 때문에 컴파일 오류 안 뜸
- 근데 파라미터에 맞는 생성자가 있는데 다른 생성자까지는 안 해줌

new
- 객체 생성
ex)
a = new func();
a.parameter;
int result = a.calc();
-> c++의 구조체에서 변수들을 받아오는 것과 비슷한데 여기서는 메소드도 정의 가능함

"this" reference, this()
- 그니까 자기 자신인데
- 다른 메소드를 호출했을 때 객체 자신의 레퍼런스를 전달할 때
- 아니 그러니까 나도 모르겠어 이건 그냥 넘겨

객체 치환
- 그러니까 그 얘는 변수 자체가 복사되는게 아니고 레퍼런스가 복사되는데
- rvalue가 가지는 값을 지정한 레퍼런스(어디서 가져왔냐)를 복사해서
- 어디서 복사할지를 가져오는거임
